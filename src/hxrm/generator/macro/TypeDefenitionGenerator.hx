package hxrm.generator.macro;

import hxrm.generator.extensions.InitializersGeneratorExtension;
import hxrm.generator.extensions.IGeneratorExtension;
import hxrm.analyzer.initializers.BindingInitializator;
import hxrm.analyzer.initializers.IInitializator;
import hxrm.analyzer.QNameUtils;
import hxrm.utils.TypeUtils;
import hxrm.analyzer.NodeAnalyzer;
import hxrm.analyzer.NodeScope;
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;
import hxrm.parser.mxml.MXMLNode;
import hxrm.analyzer.QName;

using StringTools;
using haxe.macro.Tools;
/**
 * ...
 * @author deep <system.grand@gmail.com>
 */
class TypeDefenitionGenerator
{
	public var pos:Position;
	private var extensions : Array<IGeneratorExtension>;
	
	public function new() 
	{
		extensions = [new InitializersGeneratorExtension(this)];
	}
	
	
	// analyzer вроде и не нужен
	public function write(analyzer : NodeAnalyzer, scope:NodeScope, type:String, file:String):TypeDefinition {
		trace('write:$type');

		var pos = Context.makePosition( { min:0, max:0, file:file } );
		var qName : QName = QNameUtils.fromHaxeTypeId(type);
		
		var typeDefinition : TypeDefinition =  {
			pack: qName.packageNameParts,
			name: qName.className,
			pos: pos,
			meta: [],
			params: [],
			isExtern: false,
			kind: TDClass(getTypePath(scope.type), null, false),
			fields:[generateCtor(scope)]
		}

		while(true) {
			var oneMoreTime : Bool = false;

			for(extension in extensions) {
				oneMoreTime = extension.generate(scope, typeDefinition, pos) || oneMoreTime;
			}

			if(!oneMoreTime) {
				break;
			}
		}
		
		return typeDefinition;
	}
	
	function generateCtor(scope:NodeScope):Field
	{
		var ctorExpr = { expr:EBlock([]), pos:pos };
		
		return {
			name: "new",
			doc: "autogenerated constructor",
			access: [APublic],
			pos: pos,
			kind: FFun({args:[], ret:null, expr:ctorExpr, params:[]})
		}
	}
	
	public function cleanCache():Void {
		
	}

	function getTypePath(t:Type):TypePath {
		var ct = Context.toComplexType(t);
		if (ct == null) throw "can't get CT of " + t;
		
		switch (ct) {
			case TPath(p): return p;
			case _:
				throw "can't get TypePath of " + t + " (" + ct + ")";
		}
	}
	
}