package hxrm.extensions.properties;

import hxrm.utils.TypeUtils;
import hxrm.extensions.properties.initializers.IItor;
import hxrm.extensions.base.IGeneratorExtension;
import haxe.macro.Context;
import haxe.macro.Type;
import hxrm.HxmrContext;
import hxrm.generator.GeneratorScope;
import haxe.macro.Context;
import hxrm.analyzer.NodeScope;
import haxe.macro.Type.ClassField;
import haxe.macro.Type.BaseType;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Expr.Position;
import hxrm.generator.GeneratorContext;
import hxrm.generator.GeneratorScope;

class PropertiesGeneratorExtension implements IGeneratorExtension {

    public function new() {

    }

	public function generate(context:HxmrContext, scope:GeneratorScope):Bool {

		if(scope.ctorExprs == null) {
			return true;
		}
        
        scope.itorExprs = new Map();

        for (field in scope.context.node.fields) {
            parseFieldInitializator(context, scope, field.name, field.type);
        }
		
		processScope(context, scope, scope.context.node, scope.ctorExprs, "this");

		return false;
	}

	function processScope(context : HxmrContext, scope : GeneratorScope, nodeScope : NodeScope, exprs : Array<Expr>, forField : String) : Void {

        for (fieldName in nodeScope.initializers.keys()) {
            var res = parseBindingInitializator(context, scope, nodeScope, fieldName, nodeScope.initializers.get(fieldName), exprs);
            exprs.push(macro $i{forField}.$fieldName = $res);
        }
    }

    function parseFieldInitializator(context : HxmrContext, scope : GeneratorScope, fieldName : String, fieldType : Type) : Void {

        var fieldComplexType : ComplexType = Context.toComplexType(fieldType);

        var field : Field = {
            name : fieldName,
            doc : null,//"autogenerated NodeScope field " + initializator.type,
            access : [APublic],
            pos : scope.context.pos,
            kind : FVar(fieldComplexType)
        };
        scope.typeDefinition.fields.unshift(field);
    }

    function parseBindingInitializator(context:HxmrContext, scope:GeneratorScope, nodeScope : NodeScope, fieldName : String, iitor : IItor, exprs : Array<Expr>) : Expr {

        return switch(iitor) {
            case InitValue(itor):
                var value = getValue(scope, itor.value);
                macro $value;

            case InitArray(itor):
                var values : Array<Expr> = [];
                for(childInit in itor.value) {
                    values.push(parseBindingInitializator(context, scope, nodeScope, childInit.name, childInit.itor, exprs));
                }
                {
                    expr : EArrayDecl(values),
                    pos : Context.currentPos()
                };

            case InitNodeScope(itor):
                var exprs : Array<Expr> = [];

                generateInitFunction(context, scope, fieldName, itor.value, exprs);

                var initFunctionName = generateInitializerName(fieldName);
                macro $i { initFunctionName } ();
        }
    }

    function generateInitFunction(context:HxmrContext, scope:GeneratorScope, fieldName : String, initScope : NodeScope, exprs : Array<Expr>) : Void {

        var funName = generateInitializerName(fieldName);
        for(field in scope.typeDefinition.fields) {
            if(field.name == funName) {
                return;
            }
        }

        var builders : Array<Expr> = [];

        scope.itorExprs.set(fieldName, builders);
        
        var ctor = {
            expr : ENew({
                    name : initScope.typeName.className,
                    pack : initScope.typeName.packageNameParts,
                    params : [] // TODO ctor params
                },
                []
            ),
            pos : scope.context.pos
        }

        var ctor = macro $i {fieldName} = ${ctor};

        processScope(context, scope, initScope, builders, fieldName);

        var ifExpr : Expr = {
            expr : EIf({
                    expr : EBinop(
                        OpEq,
                        {
                            expr : EConst(CIdent(fieldName)),
                            pos : scope.context.pos
                        },
                        {
                            expr : EConst(CIdent("null")),
                            pos : scope.context.pos
                        }
                    ),
                    pos : scope.context.pos
                },
                {
                    expr : EBlock([ctor,
                        {
                            expr : EBlock(builders),
                            pos : scope.context.pos
                        }
                    ]),
                    pos : scope.context.pos
                },
                null
            ),
            pos : scope.context.pos
        };
        
        exprs.push(ifExpr);
        
        exprs.push(macro return $i { fieldName });

        var initFunction : Field = {
            name: funName,
            doc: null,//'"autogenerated NodeScope init function",
            access: [APrivate, AInline],
            pos: scope.context.pos,
            kind: FFun({
                args:[],
                ret:null,
                params:[],
                expr: {
                    expr : EBlock(exprs),
                    pos : scope.context.pos
                }
            })
        }
        scope.typeDefinition.fields.push(initFunction);
    }

    function getValue(scope : GeneratorScope, value : Dynamic) : Expr {
        try {
            return Context.parse(value, scope.context.pos);
        } catch (e:Dynamic) {
            trace(e);
            //TODO throw " can't parse value: " + e;
        }
        return null;
    }

    inline function generateInitializerName(fieldName : String) : String {
        return "init_" + fieldName;
    }

}
