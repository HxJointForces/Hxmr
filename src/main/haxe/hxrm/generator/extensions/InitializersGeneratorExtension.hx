package hxrm.generator.extensions;

import haxe.macro.TypeTools;
import hxrm.utils.TypeUtils;
import haxe.macro.Context;
import hxrm.analyzer.NodeScope;
import hxrm.analyzer.initializers.NodeScopeInitializator;
import haxe.macro.Type.ClassField;
import hxrm.analyzer.initializers.BindingInitializator;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Expr.Position;
import hxrm.generator.GeneratorContext;
import hxrm.generator.GeneratorScope;

class InitializersGeneratorExtension extends GeneratorExtensionBase {

	public override function generate(context:HxmrContext, scope:GeneratorScope):Bool {

		if(scope.ctor == null) {
			return true;
		}
		
		// initializers
		var initializers = scope.context.node.initializers;
		for (initializatorEnum in initializers.iterator()) {
			switch(initializatorEnum) {
				case InitBinding(initializator): parseBindingInitializator(context, scope, initializator);
				case InitNodeScope(initializator): parseNodeScopeInitializator(context, scope, initializator);
			}
		}

		return false;
	}

	function parseBindingInitializator(context:HxmrContext, scope:GeneratorScope, initializator : BindingInitializator) : Void {
		var fieldName : String = initializator.fieldName;
		var field : ClassField = scope.context.node.getFieldByName(fieldName);

		var value = null;
		try {
			value = Context.parseInlineString(initializator.value, scope.context.pos);
		} catch (e:Dynamic) {
			throw "can't parse value: " + e;
		}
		
		var valueType = Context.typeof(value);
		var res = if (Context.unify(valueType, field.type)) {
			macro $value;
		} else {
			// extensions must be here
			var fieldCT = scope.context.node.context.getClassType(field.type);
			switch([fieldCT.module, fieldCT.name]) {
				case ["String", "String"]	: macro Std.string($value);
				case ["Int", "Int"]			: macro Std.parseInt(Std.string($value));
				case ["Float", "Float"]		: macro Std.parseFloat(Std.string($value));
				case _: throw 'can\'t unify value:$valueType to fieldType:${field.type}';
			}
		}

		if(res != null) {
			var expr = macro $i { fieldName } = $res;

			scope.ctorExprs.push(expr);
		}
	}

	function parseNodeScopeInitializator(context : HxmrContext, scope : GeneratorScope, initializator : NodeScopeInitializator) : Void {
	
		var fieldName = initializator.id;
		if(fieldName == null) {
			//TODO
			trace("fieldName is null!!");
			return;
		}
		var fieldComplexType : ComplexType = Context.toComplexType(initializator.scope.type);

		var fieldInitializerName = generateInitializerName(fieldName);
		
		var exprs : Array<Expr> = [];
		
		var fieldTypeString : String = TypeTools.toString(initializator.scope.type);
		
		exprs.push(macro if($i { fieldName } != null) return $i {fieldName});
		
		exprs.push({
			expr : EBinop(OpAssign, {
					expr : EConst(CIdent(fieldName)),
					pos : scope.context.pos
				}, {
					expr : ENew({
							name : initializator.scope.typeName.className,
							pack : initializator.scope.typeName.packageNameParts,
							params : []
						},
						[]),
				pos : scope.context.pos
			}),
			pos :scope.context.pos
		});
		
		exprs.push(macro return $i { fieldName });
		
		var initFunction = {
			name: fieldInitializerName,
			doc: "autogenerated NodeScope initializator",
			access: [APrivate],
			pos: scope.context.pos,
			kind: FFun({
				args:[],
				ret:fieldComplexType,
				params:[],
				expr: {
					expr : EBlock(exprs),
					pos : scope.context.pos
				}
			})
		}

		scope.typeDefinition.fields.push(initFunction);
		
		var field = {
			name : fieldName,
			doc : "autogenerated NodeScope field",
			access : [APrivate],
			pos : scope.context.pos,
			kind : FVar(fieldComplexType)
		}
		scope.typeDefinition.fields.push(field);
		
		var expr = macro $i { fieldInitializerName }();

		scope.ctorExprs.push(expr);
	}

	function generateInitializerName(fieldName : String) : String {
		return "init_" + fieldName;
	}

}
