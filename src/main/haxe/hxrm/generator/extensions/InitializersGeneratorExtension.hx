package hxrm.generator.extensions;

import haxe.CallStack;
import haxe.macro.TypeTools;
import haxe.macro.Printer;
import haxe.macro.ExprTools;
import haxe.macro.Context;
import hxrm.utils.TypeUtils;
import haxe.macro.ComplexTypeTools;
import hxrm.generator.GeneratorScope;
import haxe.macro.TypeTools;
import haxe.macro.Context;
import hxrm.analyzer.NodeScope;
import hxrm.analyzer.initializers.FieldInitializator;
import haxe.macro.Type.ClassField;
import hxrm.analyzer.initializers.BindingInitializator;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Expr.Position;
import haxe.macro.Type;
import hxrm.generator.GeneratorContext;
import hxrm.generator.GeneratorScope;

class InitializersGeneratorExtension extends GeneratorExtensionBase {

	public override function generate(context:HxmrContext, scope:GeneratorScope):Bool {

		if(scope.ctor == null) {
			return true;
		}
		
		processScope(context, scope, scope.context.node, scope.ctorExprs, "this");

		return false;
	}

	function processScope(context : HxmrContext, scope : GeneratorScope, nodeScope : NodeScope, exprs : Array<Expr>, forField : String) : Void {

		// initializers
		var initializers = nodeScope.initializers;
		for (fieldName in initializers.keys()) {
			switch(initializers.get(fieldName)) {
				case InitNodeScope(initializator):
					parseFieldInitializator(context, scope, fieldName, initializator);
				case InitBinding(initializator):
			}
			//trace("\n" + (new Printer("   ")).printTypeDefinition(scope.typeDefinition, true));
		}
		for (fieldName in initializers.keys()) {
			switch(initializers.get(fieldName)) {
				case InitBinding(initializator):
					parseBindingInitializator(context, scope, nodeScope, fieldName, initializator, exprs, ExprTools.toFieldExpr([forField, fieldName]));
				case InitNodeScope(initializator):
					parseBindingInitializator(context, scope, nodeScope, fieldName, initializator, exprs, ExprTools.toFieldExpr([forField, fieldName]));
			}
			//trace("\n" + (new Printer("   ")).printTypeDefinition(scope.typeDefinition, true));
		}
	}

	function parseFieldInitializator(context : HxmrContext, scope : GeneratorScope, fieldName : String, initializator : FieldInitializator) : Void {

		//var fieldName : String = initializator.fieldName;
		if(fieldName == null) {
			//TODO
			trace("fieldName is null!!");
			return null;
		}
		var fieldComplexType : ComplexType = Context.toComplexType(initializator.fieldType);

		var field : Field = {
			name : initializator.fieldName,
			doc : "autogenerated NodeScope field",
			access : [APublic],
			pos : scope.context.pos,
			kind : FVar(fieldComplexType)
		};
		scope.typeDefinition.fields.push(field);
	}
	
	function getBaseType(type : Type) : BaseType {
		if(type == null) {
			throw "type is null!";
		}
		return switch(type) {
			case TAbstract( t, params ):
				t.get();
			case TInst(t, parsms):
				t.get();
			case TDynamic(t):
				getBaseType(t);
			case _: throw "assert" + type;
		}
	}

	function parseBindingInitializator(context:HxmrContext, scope:GeneratorScope, nodeScope : NodeScope, fieldName : String, initializator : BindingInitializator, exprs : Array<Expr>, assignTarget : Expr) : Void {
		//var fieldName : String = initializator.fieldName;
		if(fieldName == null) {
			trace(initializator.value);
		}
		var fieldClassType = getBaseType(getFieldTypeByName(scope, nodeScope, initializator.fieldName));
		
		var initFunction : Field;
		var res : Expr = switch([fieldClassType.module, fieldClassType.name]) {
			
			case ["String", "String"]:
				var value = getValue(scope, initializator.value);
				macro $value;
			
			case ["Int", "Int"] | ["StdTypes", "Int"]:
				var value = getValue(scope, initializator.value);
				macro Std.parseInt($value);

			case ["Float", "Float"] | ["StdTypes", "Float"]:
				var value = getValue(scope, initializator.value);
				macro Std.parseFloat($value);

			case _:
				var exprs : Array<Expr> = [];
				var initScope : NodeScope = cast(initializator.value, NodeScope);

				exprs.push(macro if($i { initializator.fieldName } != null) return $i {initializator.fieldName});
				
			var ctor = {
					expr : ENew({
						name : initScope.typeName.className,
						pack : initScope.typeName.packageNameParts,
						params : []
					},
					[]),
					pos : scope.context.pos
				}
	
				var assignTarget = macro $i {initializator.fieldName};
				exprs.push(macro $assignTarget = ${ctor});

				processScope(context, scope, initScope, exprs, initializator.fieldName);
	
				exprs.push(macro return $i { initializator.fieldName });

				initFunction = {
					name: generateInitializerName(initializator.fieldName),
					doc: "autogenerated NodeScope init function",
					access: [APrivate],
					pos: scope.context.pos,
					kind: FFun({
						args:[],
						ret:null,
						params:[],
						expr: {
							expr : EBlock(exprs),
							pos : scope.context.pos
						}
					})
				}
	
				macro $i { initFunction.name }();
		};

		if(res != null) {
			exprs.push(macro $assignTarget = $res);
		}
		
		if(initFunction != null) {
			scope.typeDefinition.fields.push(initFunction);
		}
	}

	function getValue(scope : GeneratorScope, value : Dynamic) : Expr {
		try {
			return Context.parseInlineString(value, scope.context.pos);
		} catch (e:Dynamic) {
			throw " can't parse value: " + e;
		}
		return null;
	}

	function getFieldTypeByName(scope : GeneratorScope, nodeScope : NodeScope, fieldName : String) : Type {

		var field : ClassField = nodeScope.getFieldByName(fieldName);
		if(field != null)
		{
			return field.type;
		}
		
		for(field in scope.typeDefinition.fields) {
			if(field.name == fieldName) {
				return getFieldType(field);
			}
		}
		
		return null;
	}
	
	function getFieldType(field : Field) : Type {
		return switch(field.kind) {
			case FVar( type, expr ):
				ComplexTypeTools.toType(type);
			case _: throw "assert";
		}
	}

	inline function generateInitializerName(fieldName : String) : String {
		return "init_" + fieldName;
	}

}
