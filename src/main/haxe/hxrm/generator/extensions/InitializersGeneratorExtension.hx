package hxrm.generator.extensions;

import haxe.macro.ComplexTypeTools;
import hxrm.generator.GeneratorScope;
import haxe.macro.TypeTools;
import haxe.macro.Context;
import hxrm.analyzer.NodeScope;
import hxrm.analyzer.initializers.FieldInitializator;
import haxe.macro.Type.ClassField;
import hxrm.analyzer.initializers.BindingInitializator;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Expr.Position;
import haxe.macro.Type;
import hxrm.generator.GeneratorContext;
import hxrm.generator.GeneratorScope;

class InitializersGeneratorExtension extends GeneratorExtensionBase {

	public override function generate(context:HxmrContext, scope:GeneratorScope):Bool {

		if(scope.ctor == null) {
			return true;
		}
		
		// initializers
		var initializers = scope.context.node.initializers;
		for (initializatorEnum in initializers) {
			switch(initializatorEnum) {
				case InitNodeScope(initializator): parseFieldInitializator(context, scope, initializator);
				case InitBinding(initializator):
			}
		}
		for (initializatorEnum in initializers) {
			switch(initializatorEnum) {
				case InitBinding(initializator): parseBindingInitializator(context, scope, initializator);
				case InitNodeScope(initializator):
			}
		}

		return false;
	}

	function getValue(scope : GeneratorScope, initializator : BindingInitializator) : Expr {
		try {
			return Context.parseInlineString(initializator.value, scope.context.pos);
		} catch (e:Dynamic) {
			throw initializator.fieldName + " can't parse value: " + e;
		}
		return null;
	}
	
	function getFieldType(scope : GeneratorScope, fieldName : String) : Type {
		
		for(field in scope.typeDefinition.fields) {
			if(field.name == fieldName) {
				switch(field.kind) {
					case FVar( type, expr ):
						return ComplexTypeTools.toType(type);
					case _: throw "assert";
				}
			}
		}

		var field : ClassField = scope.context.node.getFieldByName(fieldName);
		return field.type;
	}

	function parseBindingInitializator(context:HxmrContext, scope:GeneratorScope, initializator : BindingInitializator) : Void {
		var fieldName : String = initializator.fieldName;

		var fieldType = getFieldType(scope, fieldName);
		var fieldClassType : ClassType = scope.context.node.context.getClassType(fieldType);
		var res = switch([fieldClassType.module, fieldClassType.name]) {
			
			case ["String", "String"]:
				var value = getValue(scope, initializator);
				macro Std.string($value);
			
			case ["Int", "Int"]:
				var value = getValue(scope, initializator);
				macro Std.parseInt(Std.string($value));

			case ["Float", "Float"]:
				var value = getValue(scope, initializator);
				macro Std.parseFloat(Std.string($value));

			case _:
				var exprs : Array<Expr> = [];
				var initScope : NodeScope = cast(initializator.value, NodeScope);
				var fieldComplexType : ComplexType = Context.toComplexType(fieldType);

				exprs.push(macro if($i { fieldName } != null) return $i {fieldName});
				var ctor = {
					expr : ENew({
						name : initScope.typeName.className,
						pack : initScope.typeName.packageNameParts,
						params : []
					},
					[]),
					pos : scope.context.pos
				}
	
				exprs.push({
					expr : EBinop(OpAssign, {
						expr : EConst(CIdent(fieldName)),
						pos : scope.context.pos
					}, ctor),
					pos : scope.context.pos
				});
	
				exprs.push(macro return $i { fieldName });
	
				var initFunction = {
					name: generateInitializerName(fieldName),
					doc: "autogenerated NodeScope init function",
					access: [APrivate],
					pos: scope.context.pos,
					kind: FFun({
						args:[],
						ret:fieldComplexType,
						params:[],
						expr: {
							expr : EBlock(exprs),
							pos : scope.context.pos
						}
					})
				}
	
				scope.typeDefinition.fields.push(initFunction);
	
				macro $i { initFunction.name }();
		};

		if(res != null) {
			scope.ctorExprs.push(macro $i { fieldName } = $res);
		}
	}

	function parseFieldInitializator(context : HxmrContext, scope : GeneratorScope, initializator : FieldInitializator) : Void {
	
		var fieldName : String = initializator.fieldName;
		if(fieldName == null) {
			//TODO
			trace("fieldName is null!!");
			return;
		}
		var fieldComplexType : ComplexType = Context.toComplexType(initializator.fieldType);

		var field : Field = {
			name : fieldName,
			doc : "autogenerated NodeScope field",
			access : [APublic],
			pos : scope.context.pos,
			kind : FVar(fieldComplexType)
		};
		scope.typeDefinition.fields.push(field);

		parseBindingInitializator(context, scope, initializator);
		
	}

	inline function generateInitializerName(fieldName : String) : String {
		return "init_" + fieldName;
	}

}
