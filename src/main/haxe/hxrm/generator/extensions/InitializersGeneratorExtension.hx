package hxrm.generator.extensions;

import haxe.macro.TypeTools;
import hxrm.utils.TypeUtils;
import haxe.macro.Context;
import hxrm.analyzer.NodeScope;
import hxrm.analyzer.initializers.NodeScopeInitializator;
import haxe.macro.Type.ClassField;
import hxrm.analyzer.initializers.BindingInitializator;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Expr.Position;
import hxrm.generator.GeneratorContext;
import hxrm.generator.GeneratorScope;

class InitializersGeneratorExtension extends GeneratorExtensionBase {

	public override function generate(context:HxmrContext, scope:GeneratorScope):Bool {

		if(scope.ctor == null) {
			return true;
		}
		
		// initializers
		var initializers = scope.context.node.initializers;
		for (initializatorEnum in initializers) {
			switch(initializatorEnum) {
				case InitNodeScope(initializator): parseNodeScopeInitializator(context, scope, initializator);
				case InitBinding(initializator):
			}
		}
		for (initializatorEnum in initializers) {
			switch(initializatorEnum) {
				case InitBinding(initializator): parseBindingInitializator(context, scope, initializator);
				case InitNodeScope(initializator):
			}
		}

		return false;
	}

	function parseBindingInitializator(context:HxmrContext, scope:GeneratorScope, initializator : BindingInitializator) : Void {
		var fieldName : String = initializator.fieldName;
		var field : ClassField = scope.context.node.getFieldByName(fieldName);

		var value = null;
		try {
			value = Context.parseInlineString(initializator.value, scope.context.pos);
		} catch (e:Dynamic) {
			throw "can't parse value: " + e;
		}
		
		var fieldCT = scope.context.node.context.getClassType(field.type);
		var res = switch([fieldCT.module, fieldCT.name]) {
				case ["String", "String"]	: macro Std.string($value);
				case ["Int", "Int"]			: macro Std.parseInt(Std.string($value));
				case ["Float", "Float"]		: macro Std.parseFloat(Std.string($value));
				case _						: macro $value;
			}

		if(res != null) {
			var expr = macro $i { fieldName } = $res;

			scope.ctorExprs.push(expr);
		}
	}

	function parseNodeScopeInitializator(context : HxmrContext, scope : GeneratorScope, initializator : NodeScopeInitializator) : Void {
	
		var fieldName : String = initializator.id;
		var initializatorName = initializator.id;
		if(initializatorName == null) {
			//TODO
			trace("initializatorName is null!!");
			return;
		}
		var fieldComplexType : ComplexType = Context.toComplexType(initializator.scope.type);

		scope.typeDefinition.fields.push({
			name : initializatorName,
			doc : "autogenerated NodeScope field",
			access : [APrivate],
			pos : scope.context.pos,
			kind : FVar(fieldComplexType)
		});

		var exprs : Array<Expr> = [];
		
		exprs.push(macro if($i { initializatorName } != null) return $i {initializatorName});
		
		var fieldCT = scope.context.node.context.getClassType(initializator.scope.type);
		var ctor = switch([fieldCT.module, fieldCT.name]) {
			case ["String", "String"]	: macro Std.string("1");
			case ["Int", "Int"]			: macro Std.parseInt(Std.string("1"));
			case ["Float", "Float"]		: macro Std.parseFloat(Std.string("1"));
			case _: {
					expr : ENew({
						name : initializator.scope.typeName.className,
						pack : initializator.scope.typeName.packageNameParts,
						params : []
					},
					[]),
					pos : scope.context.pos
				}
		};
		
		exprs.push({
			expr : EBinop(OpAssign, {
					expr : EConst(CIdent(initializatorName)),
					pos : scope.context.pos
				}, ctor),
			pos :scope.context.pos
		});
		
		exprs.push(macro return $i { initializatorName });
		
		var initFunction = {
			name: generateInitializerName(initializatorName),
			doc: "autogenerated NodeScope initializator",
			access: [APrivate],
			pos: scope.context.pos,
			kind: FFun({
				args:[],
				ret:fieldComplexType,
				params:[],
				expr: {
					expr : EBlock(exprs),
					pos : scope.context.pos
				}
			})
		}

		scope.typeDefinition.fields.push(initFunction);

		scope.ctorExprs.push(macro $i { fieldName } = $i { initFunction.name }());
	}

	inline function generateInitializerName(fieldName : String) : String {
		return "init_" + fieldName;
	}

}
