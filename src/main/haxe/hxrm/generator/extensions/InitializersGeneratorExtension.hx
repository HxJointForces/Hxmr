package hxrm.generator.extensions;

import haxe.macro.ExprTools;
import haxe.macro.Context;
import hxrm.utils.TypeUtils;
import haxe.macro.ComplexTypeTools;
import hxrm.generator.GeneratorScope;
import haxe.macro.TypeTools;
import haxe.macro.Context;
import hxrm.analyzer.NodeScope;
import hxrm.analyzer.initializers.FieldInitializator;
import haxe.macro.Type.ClassField;
import hxrm.analyzer.initializers.BindingInitializator;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Expr.Position;
import haxe.macro.Type;
import hxrm.generator.GeneratorContext;
import hxrm.generator.GeneratorScope;

class InitializersGeneratorExtension extends GeneratorExtensionBase {

	public override function generate(context:HxmrContext, scope:GeneratorScope):Bool {

		if(scope.ctor == null) {
			return true;
		}
		
		// initializers
		var initializers = scope.context.node.initializers;
		for (initializatorEnum in initializers) {
			switch(initializatorEnum) {
				case InitNodeScope(initializator):
					var field = parseFieldInitializator(context, scope, initializator);
					if(field == null) {
						trace("null from parseFieldInitializator");
						continue;
					} else {

						scope.typeDefinition.fields.push(field);
					}

				case InitBinding(initializator):
			}
		}
		for (initializatorEnum in initializers) {
			var fieldName;
			var result = switch(initializatorEnum) {
				case InitBinding(initializator):
					fieldName = initializator.fieldName;
					parseBindingInitializator(context, scope, scope.context.node, initializator);
				
				case InitNodeScope(initializator):
					fieldName = initializator.fieldName;
					parseBindingInitializator(context, scope, scope.context.node, initializator);
			}
			
			if(result.e != null) {
				scope.ctorExprs.push(macro $i { fieldName } = ${result.e});
			}
			
			if(result.f != null) {
				scope.typeDefinition.fields.push(result.f);
			}
		}

		return false;
	}

	function parseFieldInitializator(context : HxmrContext, scope : GeneratorScope, initializator : FieldInitializator) : Field {

		var fieldName : String = initializator.fieldName;
		if(fieldName == null) {
			//TODO
			trace("fieldName is null!!");
			return null;
		}
		var fieldComplexType : ComplexType = Context.toComplexType(initializator.fieldType);

		var field : Field = {
			name : fieldName,
			doc : "autogenerated NodeScope field",
			access : [APublic],
			pos : scope.context.pos,
			kind : FVar(fieldComplexType)
		};
		
		return field;
	}
	
	function getBaseType(type : Type) : BaseType {
		if(type == null) {
			throw "type is null!";
		}
		return switch(type) {
			case TAbstract( t, params ):
				t.get();
			case TInst(t, parsms):
				t.get();
			case TDynamic(t):
				getBaseType(t);
			case _: throw "assert" + type;
		}
	}

	function parseBindingInitializator(context:HxmrContext, scope:GeneratorScope, nodeScope : NodeScope, initializator : BindingInitializator) : {e : Expr, f : Field} {
		var fieldName : String = initializator.fieldName;
		var fieldClassType = getBaseType(getFieldTypeByName(scope, nodeScope, fieldName));
		
		var initFunction : Field;
		var res : Expr = switch([fieldClassType.module, fieldClassType.name]) {
			
			case ["String", "String"]:
				var value = getValue(scope, initializator.value);
				macro $value;
			
			case ["Int", "Int"] | ["StdTypes", "Int"]:
				var value = getValue(scope, initializator.value);
				macro Std.parseInt($value);

			case ["Float", "Float"] | ["StdTypes", "Float"]:
				var value = getValue(scope, initializator.value);
				macro Std.parseFloat($value);

			case _:
				var exprs : Array<Expr> = [];
				var initScope : NodeScope = cast(initializator.value, NodeScope);

				exprs.push(macro if($i { fieldName } != null) return $i {fieldName});
				var ctor = {
					expr : ENew({
						name : initScope.typeName.className,
						pack : initScope.typeName.packageNameParts,
						params : []
					},
					[]),
					pos : scope.context.pos
				}
	
				var assignTarget = macro $i {fieldName};
				exprs.push(macro $assignTarget = ${ctor});


			for(childInitializatorEnum in initScope.initializers) {
				switch(childInitializatorEnum) {
					case InitBinding(childInitializator):
						var childFieldName = childInitializator.fieldName;
		
						var childFieldType : BaseType = getBaseType(initScope.getFieldByName(childFieldName).type);
		
						if(childFieldType == null) {
							throw "assert";
						}
						
						var result = parseBindingInitializator(context, scope, initScope, childInitializator);
		
						if(result.e != null) {
						
							var assignTarget = ExprTools.toFieldExpr([fieldName, childFieldName]);
							
							exprs.push(macro $assignTarget = ${result.e});
						}
		
						if(result.f != null) {
							scope.typeDefinition.fields.push(result.f);
						}
		
					case InitNodeScope(childInitializator): throw "assert";
				}
			}
			
	
				exprs.push(macro return $i { fieldName });

				initFunction = {
					name: generateInitializerName(fieldName),
					doc: "autogenerated NodeScope init function",
					access: [APrivate],
					pos: scope.context.pos,
					kind: FFun({
						args:[],
						ret:null,
						params:[],
						expr: {
							expr : EBlock(exprs),
							pos : scope.context.pos
						}
					})
				}
	
				macro $i { initFunction.name }();
		};

		return {e : res, f : initFunction};
	}

	function getValue(scope : GeneratorScope, value : Dynamic) : Expr {
		try {
			return Context.parseInlineString(value, scope.context.pos);
		} catch (e:Dynamic) {
			throw " can't parse value: " + e;
		}
		return null;
	}

	function getFieldTypeByName(scope : GeneratorScope, nodeScope : NodeScope, fieldName : String) : Type {

		for(field in scope.typeDefinition.fields) {
			if(field.name == fieldName) {
				return getFieldType(field);
			}
		}

		var field : ClassField = nodeScope.getFieldByName(fieldName);
		return field.type;
	}
	
	function getFieldType(field : Field) : Type {
		return switch(field.kind) {
			case FVar( type, expr ):
				ComplexTypeTools.toType(type);
			case _: throw "assert";
		}
	}

	inline function generateInitializerName(fieldName : String) : String {
		return "init_" + fieldName;
	}

}
